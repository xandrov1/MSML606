# Problem 1:
# Generate an expression tree (Binary tree) from a postfix expression
# Requirements:
# ➢ The input is a list of strings (e.g., [“3”, “4”, “+”, “2”, “*”]), which is parsed from a comma-separated CSV
# ➢ Support basic operators: +, -, *, and /
# ➢ Return the root node of the constructed expression tree

class Node: # Node class
    def __init__(self, data=None):
        self.data = data # Value store in node
        self.right = None # Connection to node's right
        self.left = None # Connection to node's left

def treeGenerator(ray): # Generates tree from list (postfix expression list)
    stack = [] # Stack to contain whole tree

    for element in ray: # Iterate through each element
        node = Node(element) # Create node instance per element

        if element in "+-*/": # If it's an operator; works cause postfix lists can't start with an operators
            node.right = stack.pop() # Pop and connect right first (Stacks are LIFO)
            node.left = stack.pop() # Pop and connect left
            stack.append(node) # Push back in stack

        else: # If it's an operand
            stack.append(node) # Push back in stack

    return stack.pop() # Return root

# roots = [] # Appending roots to this list
# with open("data\p1_construct_tree.csv", "r") as file: # Open file to read
#     for i, line in enumerate(file): # Call function on each line isntead of calling it once?

#         root = treeGenerator(line.strip().split(",")) # Get root node with connections to other nodes. Pass list generated by split after stripping line of " " and "\n"
#         roots.append(root) # Store root
#         print(f"Root node: {root.data}") # Print root


# Problem 2:
# Implement functions to print prefix, infix, postfix expressions using traversal methods.
# Use pre-order traversal (root, left, right) to generate prefix notation. 
# Use in-order traversal (left, root, right) for infix notation with appropriate parentheses. 
# Use post-order traversal (left, right, root) to generate postfix notation.
# Requirements:
# ➢ Return the expression as a list of elements
# ➢ For infix: Add parentheses to maintain correct operator precedence (even for the
# outermost expressions. Also, treat parentheses as individual elements in the returned list)
# ➢ Handle empty trees gracefully
# Looking at .csv for this assignment: Column 1 is input, the others are expected output 

import csv
roots_p2 = [] # Trees storage from inputs
# Expected outputs stored in each corresponding type
actual_prefix = []
actual_infix = []
actual_postfix = []

with open("data\p2_traversals.csv", "r") as file: # Open file 
    reader = csv.reader(file) # Save the Pandas

    for row in reader:
        input = row[0].split(",") # reader already splits preserving fields (delimited by quotes: "") but treeGenerator expects a list of strings out of each field
        root = treeGenerator(input) # generate tree
        roots_p2.append(root) # Save tree

        # Save expected outputs
        actual_prefix.append(row[1])
        actual_infix.append(row[2])
        actual_postfix.append(row[3])

def preOrder_traversal(root): 
    if root is None: # Base case 
        return [] 
        
    # Returning a list instead of using a global list 
    return [root.data] + preOrder_traversal(root.left) + preOrder_traversal(root.right) # Concatenates current, left subtree values and right subtree values 
    # Root -> left -> right

def inOrder_traversal(root): 
    if root is None: 
        return [] 
    
    if root.left is None and root.right is None: # Check current node is a leaf
        return [root.data] # Return it with no parenthesis then
    
    # Returning list, current isn't leaf so add parenthesis 
    return ["("] + inOrder_traversal(root.left) + [root.data] + inOrder_traversal(root.right) + [")"] 
    # Left -> root -> right

def postOrder_traversal(root): 
    if root is None: 
        return [] 

    # Returning list 
    return postOrder_traversal(root.left) + postOrder_traversal(root.right) + [root.data] 
    # Left -> right -> root

for i, root in enumerate(roots_p2):
    # Join list returned by traversal lists into one 
    prefix = ",".join(preOrder_traversal(root)) # with commas in between!!!
    infix = ",".join(inOrder_traversal(root))
    postfix = ",".join(postOrder_traversal(root))
    print(infix)

    # Compare lists to expected values
    assert prefix == actual_prefix[i], f"Prefix mismatch at row {i}"
    assert infix == actual_infix[i], f"Infix mismatch at row {i}"
    assert postfix == actual_postfix[i], f"Postfix mismatch at row {i}"




