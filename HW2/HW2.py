# Problem 1:
# Generate an expression tree (Binary tree) from a postfix expression
# Requirements:
# ➢ The input is a list of strings (e.g., [“3”, “4”, “+”, “2”, “*”]), which is parsed from a comma-separated CSV
# ➢ Support basic operators: +, -, *, and /
# ➢ Return the root node of the constructed expression tree

class Node: # Node class
    def __init__(self, data=None):
        self.data = data # Value store in node
        self.right = None # Connection to node's right
        self.left = None # Connection to node's left

def treeGenerator(ray): # Generates tree from list (postfix expression list)
    stack = [] # Stack to contain whole tree

    for element in ray: # Iterate through each element
        node = Node(element) # Create node instance per element

        if element in "+-*/": # If it's an operator; works cause postfix lists can't start with an operators
            node.right = stack.pop() # Pop and connect right first (Stacks are LIFO)
            node.left = stack.pop() # Pop and connect left
            stack.append(node) # Push back in stack

        else: # If it's an operand
            stack.append(node) # Push back in stack

    return stack.pop() # Return root

# roots = [] # Appending roots to this list
# with open("data/p1_construct_tree.csv", "r") as file: # Open file to read
#     for i, line in enumerate(file): # Call function on each line isntead of calling it once?

#         root = treeGenerator(line.strip().split(",")) # Get root node with connections to other nodes. Pass list generated by split after stripping line of " " and "\n"
#         roots.append(root) # Store root
#         print(f"Root node: {root.data}") # Print root


# Problem 2:
# Implement functions to print prefix, infix, postfix expressions using traversal methods.
# Use pre-order traversal (root, left, right) to generate prefix notation. 
# Use in-order traversal (left, root, right) for infix notation with appropriate parentheses. 
# Use post-order traversal (left, right, root) to generate postfix notation.
# Requirements:
# ➢ Return the expression as a list of elements
# ➢ For infix: Add parentheses to maintain correct operator precedence (even for the
# outermost expressions. Also, treat parentheses as individual elements in the returned list)
# ➢ Handle empty trees gracefully
# Looking at .csv for this assignment: Column 1 is input, the others are expected output 

import csv
inputs = [] # Storing inputs
roots_p2 = [] # Trees storage from inputs
# Expected outputs stored in each corresponding type
actual_prefix = []
actual_infix = []
actual_postfix = []

with open("data/p2_traversals.csv", "r") as file: # Open file 
    reader = csv.reader(file) # Save the Pandas

    for row in reader:
        input = row[0].split(",") # reader already splits preserving fields (delimited by quotes: "") but treeGenerator expects a list of strings out of each field
        inputs.append(input) # Save input
        root = treeGenerator(input) # generate tree
        roots_p2.append(root) # Save tree

        # Save expected outputs
        actual_prefix.append(row[1])
        actual_infix.append(row[2])
        actual_postfix.append(row[3])

def preOrder_traversal(root): 
    if root is None: # Base case 
        return [] 
        
    # Returning a list instead of using a global list 
    return [root.data] + preOrder_traversal(root.left) + preOrder_traversal(root.right) # Concatenates current, left subtree values and right subtree values 
    # Root -> left -> right

def inOrder_traversal(root): 
    if root is None: 
        return [] 
    
    if root.left is None and root.right is None: # Check current node is a leaf
        return [root.data] # Return it with no parenthesis then
    
    # Returning list, current isn't leaf so add parenthesis 
    return ["("] + inOrder_traversal(root.left) + [root.data] + inOrder_traversal(root.right) + [")"] 
    # Left -> root -> right

def postOrder_traversal(root): 
    if root is None: 
        return [] 

    # Returning list 
    return postOrder_traversal(root.left) + postOrder_traversal(root.right) + [root.data] 
    # Left -> right -> root

for i, root in enumerate(roots_p2):
    # Join list returned by traversal lists into one 
    prefix = ",".join(preOrder_traversal(root)) # with commas in between!!!
    infix = ",".join(inOrder_traversal(root))
    postfix = ",".join(postOrder_traversal(root))

    print(f"Input {i}: {inputs[i]}")
    print(f"Expected prefix output: {actual_prefix[i]}")
    print(f"Expected infix output: {actual_infix[i]}")
    print(f"Expected postfix output: {actual_postfix[i]}")
    print(f"Actual prefix output: {prefix}")
    print(f"Actual infix output: {infix}")
    print(f"Actual postfix output: {postfix}\n")

print("********************************************\n")


# Problem 3. Evaluate a postfix expression using a stack. That is, implement a function that
# evaluates a postfix expression without constructing an expression tree.
# Requirements:
# ➢ Accept postfix expressions as space-separated strings (unlike comma-separated in
# Problem 1)
# ➢ Implement your stack using either an array or a list (i.e., implement the functions based
# on the Stack ADT we covered in class)
#   ○ Constraints: You may use Python’s list structure as the underlying storage. While
#   you can use .append() to add elements, please ensure the implementation strictly
#   follows the logic we discussed in class (e.g., manually managing the "top" of the stack.
#   ○ Use your own stack implementation to solve problem 3
# ➢ Support operators: +, -, *, and /
# ➢ Return the numeric result of the evaluation
# ➢ Handle division by zero appropriately (e.g., raise a ZeroDivisionError or handle it so that
# the test case catches the error)

class Stack:
    def __init__(self):
        self.data = [] # List to contain elements
        self.top = -1 # Index of top element of stack (starts at -1 cause list is empty at this initialization)

    def push(self, value): # Push function
        self.top += 1 # Update index of top
        self.data.append(value) # Uses append from python lists kinda cheap

    def pop(self):
        if self.top == -1: # Check stack isn't empty
            raise IndexError("Empty stack") # Throw error
        
        self.top -= 1 # Update index of top
        return self.data.pop()

def postfixExpressionCalculator(stringy):
    s = Stack()
    expression = stringy.split() # Create expression as list of characters in string

    for token in expression:
        if token in "+-/*":
            # Maintain correct left/right operand order
            b = s.pop() # Last element is second in expression 
            a = s.pop() # Fisrt element in expression
            # Handle every operator
            if token == "+":
                s.push(a + b)
            elif token == "-":
                s.push(a - b)
            elif token == "*":
                s.push(a * b)
            elif token == "/":
                if b == 0: # Handle division by 0
                    return ("Division by zero")
                s.push(a / b)
        else:
            s.push(float(token)) # Convert numbers to float when pushing them

    return s.pop()

with open("data/p3_eval_postfix.csv", "r") as file:
    reader = csv.reader(file)
    for row in reader:
        print(f"Input: {row[0]}\nExpected output: {row[1]}\nCalculation: {postfixExpressionCalculator(row[0])}")

