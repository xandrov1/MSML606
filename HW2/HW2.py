# Problem 1:
# Generate an expression tree (Binary tree) from a postfix expression
# Requirements:
# ➢ The input is a list of strings (e.g., [“3”, “4”, “+”, “2”, “*”]), which is parsed from a comma-separated CSV
# ➢ Support basic operators: +, -, *, and /
# ➢ Return the root node of the constructed expression tree

file = open("data\p1_construct_tree.csv", "r") # Open file to read

class Node: # Node class
    def __init__(self, data=None):
        self.data = data # Value store in node
        self.right = None # Connection to node's right
        self.left = None # Connection to node's left

def treeGenerator(ray): # Generates tree from list (postfix expression list)
    stack = [] # Stack to contain whole tree

    for element in ray: # Iterate through each element
        node = Node(element) # Create node instance per element

        if element in "+-*/": # If it's an operator; works cause postfix lists can't start with an operators
            node.right = stack.pop() # Pop and connect right first (Stacks are LIFO)
            node.left = stack.pop() # Pop and connect left
            stack.append(node) # Push back in stack

        else: # If it's an operand
            stack.append(node) # Push back in stack

    return stack.pop() # Return root

roots = [] # Appending roots to this list
for i, line in enumerate(file): # Call function on each line isntead of calling it once?

    root = treeGenerator(line.strip().split(",")) # Get root node with connections to other nodes. Pass list generated by split after stripping line of " " and "\n"
    roots.append(root) # Store root
    print(f"Root node: {root.data}") # Print root


# Problem 2:
# Implement functions to print prefix, infix, postfix expressions using traversal methods.
# Use pre-order traversal (root, left, right) to generate prefix notation. 
# Use in-order traversal (left, root, right) for infix notation with appropriate parentheses. 
# Use post-order traversal (left, right, root) to generate postfix notation.
# Requirements:
# ➢ Return the expression as a list of elements
# ➢ For infix: Add parentheses to maintain correct operator precedence (even for the
# outermost expressions. Also, treat parentheses as individual elements in the returned list)
# ➢ Handle empty trees gracefully

preOrder = [] # List storing preorder of tree
def preOrder_traversal(root):

    if root is None: # Base case 
        return
    
    preOrder.append(root) # Append root

    preOrder_traversal(root.left) # Call left, return immediately with None if no left
    preOrder_traversal(root.right) # Call right, return immediately with None if no right

preOrder_traversal(roots[0])
print(preOrder) # HUHHHH??





